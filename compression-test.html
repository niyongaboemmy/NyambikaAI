<!DOCTYPE html>
<html>
  <head>
    <title>Image Compression Test</title>
  </head>
  <body>
    <h1>Image Compression Test</h1>
    <input type="file" id="fileInput" accept="image/*" />
    <button onclick="testCompression()">Test Compression</button>
    <div id="result"></div>

    <script>
      async function compressImage(file, options = {}) {
        const {
          maxSizeKB = 500,
          quality = 0.8,
          maxWidth = 2048,
          maxHeight = 2048,
          outputFormat = "jpeg",
        } = options;

        const originalSize = file.size;
        console.log(`=== Starting Compression ===`);
        console.log(
          `Original file: ${file.name}, Size: ${(originalSize / 1024).toFixed(
            2
          )}KB`
        );

        try {
          // Strategy 1: Try canvas-based compression
          const canvasResult = await compressWithCanvas(file, {
            maxSizeKB,
            quality,
            maxWidth,
            maxHeight,
            outputFormat,
          });

          if (
            canvasResult.success &&
            canvasResult.file.size <= maxSizeKB * 1024
          ) {
            console.log(`✅ Canvas compression successful`);
            return {
              ...canvasResult,
              originalSize,
              compressedSize: canvasResult.file.size,
              compressionRatio: originalSize / canvasResult.file.size,
            };
          }

          // Strategy 2: Return original if compression fails
          console.log(`⚠️ Compression failed, returning original`);
          return {
            file,
            originalSize,
            compressedSize: originalSize,
            compressionRatio: 1,
            success: true,
            error: "Compression failed, using original file",
          };
        } catch (error) {
          console.error(`❌ Compression error:`, error);
          return {
            file,
            originalSize,
            compressedSize: originalSize,
            compressionRatio: 1,
            success: false,
            error: error.message || "Unknown error",
          };
        }
      }

      async function compressWithCanvas(file, options) {
        try {
          const img = await createImageFromFile(file);
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");

          if (!ctx) {
            throw new Error("Could not get canvas context");
          }

          // Calculate new dimensions
          let { width, height } = calculateDimensions(
            img.width,
            img.height,
            options.maxWidth || 2048,
            options.maxHeight || 2048
          );

          canvas.width = width;
          canvas.height = height;

          // Draw and compress
          ctx.drawImage(img, 0, 0, width, height);

          const mimeType = `image/${options.outputFormat || "jpeg"}`;
          const quality = options.quality || 0.8;

          return new Promise((resolve) => {
            canvas.toBlob(
              (blob) => {
                if (!blob) {
                  resolve({ file, success: false });
                  return;
                }

                const compressedFile = new File(
                  [blob],
                  `${file.name.replace(/\.[^.]+$/, "")}-compressed.${
                    options.outputFormat || "jpg"
                  }`,
                  { type: mimeType }
                );

                resolve({ file: compressedFile, success: true });
              },
              mimeType,
              quality
            );
          });
        } catch (error) {
          console.error("Canvas compression failed:", error);
          return { file, success: false };
        }
      }

      function createImageFromFile(file) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          const url = URL.createObjectURL(file);

          img.onload = () => {
            URL.revokeObjectURL(url);
            resolve(img);
          };

          img.onerror = () => {
            URL.revokeObjectURL(url);
            reject(new Error("Failed to load image"));
          };

          img.src = url;
        });
      }

      function calculateDimensions(
        originalWidth,
        originalHeight,
        maxWidth,
        maxHeight
      ) {
        let { width, height } = {
          width: originalWidth,
          height: originalHeight,
        };

        // Calculate aspect ratio
        const aspectRatio = width / height;

        // Resize if needed
        if (width > maxWidth) {
          width = maxWidth;
          height = width / aspectRatio;
        }

        if (height > maxHeight) {
          height = maxHeight;
          width = height * aspectRatio;
        }

        return { width: Math.round(width), height: Math.round(height) };
      }

      async function testCompression() {
        const fileInput = document.getElementById("fileInput");
        const result = document.getElementById("result");

        if (!fileInput.files[0]) {
          result.innerHTML = "Please select a file first";
          return;
        }

        const file = fileInput.files[0];

        console.log("Testing compression...");
        const compressionResult = await compressImage(file, {
          maxSizeKB: 300,
          quality: 0.8,
          maxWidth: 1920,
          maxHeight: 1920,
          outputFormat: "jpeg",
        });

        console.log("Compression result:", compressionResult);

        result.innerHTML = `
                <h3>Compression Result:</h3>
                <pre>${JSON.stringify(compressionResult, null, 2)}</pre>
                <p>Original: ${(compressionResult.originalSize / 1024).toFixed(
                  2
                )}KB</p>
                <p>Compressed: ${(
                  compressionResult.compressedSize / 1024
                ).toFixed(2)}KB</p>
                <p>Ratio: ${compressionResult.compressionRatio.toFixed(2)}x</p>
                <p>Success: ${compressionResult.success}</p>
            `;
      }
    </script>
  </body>
</html>
